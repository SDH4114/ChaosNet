<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=0.9">
    <link rel="icon" type="image/png" href="img/ChaosNetLogo.png" />
  <link rel="shortcut icon" href="img/ChaosNetLogo.png" type="image/png"/>
  <!-- iOS home screen icon + web app meta -->
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
  <link rel="apple-touch-icon" href="/img/ChaosNetLogo.png">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-title" content="ChaosNet">

<title>ChaosNet - Video Chat</title>
  <meta name="theme-color" content="#0b0b0c">
<style>
  :root{
    --bg:#0b0b0c;
    --panel:#111214;
    --ink:#e6e6e6;
    --muted:#7f848a;
    --accent:#4c9aff;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0;
    background:var(--bg);
    color:var(--ink);
    font:14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial, sans-serif;
    overscroll-behavior:none;
  }

  /* Layout */
  .app{
    position:fixed; inset:0;
    display:grid; grid-template-rows:auto 1fr auto;
  }
  header{
    display:flex; align-items:center; gap:.75rem;
    padding: clamp(10px,2.2vmin,18px) clamp(12px,3vmin,22px);
    background:linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,0));
    border-bottom:1px solid #1b1d21;
    backdrop-filter:saturate(120%) blur(6px);
  }
  .dot{
    width:.6rem; height:.6rem; border-radius:50%;
    background:var(--muted);
    box-shadow:0 0 0 2px #0b0b0c, 0 0 0 6px rgba(76,154,255,.12);
    transition:background .25s ease;
  }
  .dot.on{ background:#30d158; box-shadow:0 0 0 2px #0b0b0c, 0 0 0 6px rgba(48,209,88,.18); }
  h1{ font-size:clamp(16px,3.2vmin,22px); margin:0; letter-spacing:.2px; }
  .spacer{flex:1}
  .pill{
    border:1px solid #23262b; background:var(--panel);
    padding:.5rem .75rem; border-radius:999px; color:var(--muted);
    display:flex; align-items:center; gap:.5rem;
  }
  .pill b{color:var(--ink); font-weight:600}
  .btn{
    appearance:none; border:1px solid #23262b; background:var(--panel);
    color:var(--ink); border-radius:12px; padding:.6rem .9rem; font-weight:600;
    cursor:pointer; transition:transform .08s ease, border-color .2s ease, background .2s ease;
  }
  .btn:active{ transform:translateY(1px) scale(.99) }
  .btn.ghost{ background:transparent }
  .btn.primary{ border-color:#2e6adb; background:linear-gradient(180deg,#2e6adb,#1c4eb6); color:white }
  .btn.toggle{ position:relative; }
  .btn.toggle.active{ outline:2px solid rgba(76,154,255,.35); box-shadow:0 0 0 3px rgba(76,154,255,.18) inset; }
  .toolbar{
    display:flex; gap:.5rem; align-items:center;
    background:linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,0));
    border-top:1px solid #1b1d21; padding:.6rem .8rem; flex-wrap:wrap;
  }
  .slider{
    display:flex; align-items:center; gap:.6rem; color:var(--muted);
    padding:.35rem .6rem; border:1px solid #23262b; border-radius:12px; background:var(--panel);
  }
  .slider input{ accent-color:var(--accent); width:140px }
  .toggle{
    display:flex; align-items:center; gap:.6rem; color:var(--muted);
    padding:.35rem .6rem; border:1px solid #23262b; border-radius:12px; background:var(--panel);
    user-select:none;
  }
  .hint{ color:var(--muted); margin-left:auto; display:flex; align-items:center; gap:.4rem }
  .kbd{ border:1px solid #23262b; background:#0f1113; padding:.2rem .45rem; border-radius:6px; color:#c9cdd3; font-variant:tabular-nums; }
  /* Stage */
  .stage{
    position:relative; overflow:hidden; background:
      radial-gradient(1200px 1200px at 80% -20%, rgba(76,154,255,.12), transparent),
      radial-gradient(1400px 900px at 10% 20%, rgba(76,154,255,.08), transparent);
  }
  video, canvas{
    position:absolute; inset:0; width:100%; height:100%;
    object-fit:cover; object-position:center;
  }
  video{
    transform: scaleX(-1); /* mirror for natural interaction */
    filter: saturate(105%) contrast(105%) brightness(95%);
  }
  canvas{ pointer-events:none; }

  /* Toast / tips */
  .toast{
    position:absolute; left:50%; top:16px; transform:translateX(-50%);
    background:#0f1113; border:1px solid #23262b; color:#d9d9d9;
    padding:.6rem .8rem; border-radius:12px; box-shadow:0 6px 24px rgba(0,0,0,.35);
    display:flex; align-items:center; gap:.6rem; z-index:10;
  }
  .link{ color:#9ec5ff; text-decoration:none; border-bottom:1px dotted #355; }
  .sr{ position:absolute; width:1px; height:1px; overflow:hidden; clip:rect(0 0 0 0); white-space:nowrap; clip-path:inset(50%); }

  /* Color palette */
  .palette{
    display:flex; align-items:center; gap:.5rem;
    padding:.35rem .6rem; border:1px solid #23262b; border-radius:12px; background:var(--panel);
  }
  .palette .label{ color:var(--muted); margin-right:.25rem; }
  .swatch{
    width:22px; height:22px; border-radius:6px; border:1px solid #23262b;
    cursor:pointer; display:inline-block; box-shadow:0 1px 0 rgba(0,0,0,.25);
    transition:transform .06s ease, box-shadow .2s ease, border-color .2s ease;
  }
  .swatch:active{ transform:scale(.95) }
  .swatch.selected{
    outline:2px solid rgba(255,255,255,.12);
    box-shadow:0 0 0 3px rgba(76,154,255,.25);
    border-color:#2e6adb;
  }
</style>
</head>
<body>
<div class="app">
  <header>
    <div class="dot" id="status-dot" title="Camera status"></div>
    <h1>Hand-Draw App</h1>
    <a class="btn ghost" id="back-chat-btn" href="select.html" title="Back to chat" style="margin-left:.25rem">← Back to Chat</a>
    <div class="spacer"></div>
    <div class="pill" id="mode-indicator" title="Pinch index & thumb to draw">
      Mode: <b id="mode-label">Idle</b>
    </div>
    <button class="btn ghost" id="clear-btn" aria-label="Clear drawing">Clear</button>
    <button class="btn" id="save-photo-btn" title="Download camera photo">Save Photo</button>
    <button class="btn" id="save-drawing-btn" title="Download drawing layer">Save Drawing</button>
    <button class="btn primary" id="save-composite-btn" title="Download camera + drawing">Save All</button>
  </header>

  <main class="stage" id="stage">
    <div class="toast" id="toast" role="status" aria-live="polite">
      Grant camera access, then pinch your <b>index</b> and <b>thumb</b> to draw ✍️
    </div>
    <video id="video" playsinline autoplay muted></video>
    <!-- overlay for optional guides (landmarks) -->
    <canvas id="overlay"></canvas>
    <!-- persistent drawing canvas -->
    <canvas id="draw"></canvas>
  </main>

  <footer class="toolbar">
    <div class="slider" title="Line thickness">
      Stroke <span id="stroke-val" class="kbd">10</span>
      <input id="stroke" type="range" min="1" max="40" step="1" value="10" />
    </div>
    <div class="palette" id="palette" title="Stroke color">
      <span class="label">Color</span>
      <button class="swatch selected" data-color="#e6e6e6" style="background:#e6e6e6" aria-label="Light gray"></button>
      <button class="swatch" data-color="#ff3b30" style="background:#ff3b30" aria-label="Red"></button>
      <button class="swatch" data-color="#ff9500" style="background:#ff9500" aria-label="Orange"></button>
      <button class="swatch" data-color="#34c759" style="background:#34c759" aria-label="Green"></button>
      <button class="swatch" data-color="#ffd60a" style="background:#ffd60a" aria-label="Yellow"></button>
      <button class="swatch" data-color="#111111" style="background:#111111" aria-label="Black"></button>
      <button class="swatch" data-color="#0a84ff" style="background:#0a84ff" aria-label="Blue"></button>
    </div>
    <button class="btn toggle" id="eraser-btn" title="Toggle eraser (E)">Eraser</button>
    <div class="toggle" title="Show tracking guides">
      <label><input id="guides" type="checkbox" /> Show guides</label>
    </div>
    <div class="hint">
      <span>Tip: keep fingers within view. Pinch threshold adapts to hand size.</span>
    </div>
  </footer>
</div>

<!-- MediaPipe Hands (client-side only) -->
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>

<script>
(function(){
  // Configure "Back to Chat" button to preserve room/target
  (function initBackToChat(){
    try{
      const backBtn = document.getElementById('back-chat-btn');
      if (!backBtn) return;
      const qp = new URLSearchParams(location.search);
      const room = qp.get('room');
      const target = qp.get('target');
      if (room || target){
        const params = [];
        if (room) params.push('room=' + encodeURIComponent(room));
        if (target) params.push('target=' + encodeURIComponent(target));
        backBtn.href = 'chat.html' + (params.length ? ('?' + params.join('&')) : '');
      } else {
        backBtn.href = 'chat.html';
      }
    } catch(_) {}
  })();
  const video = document.getElementById('video');
  const overlay = document.getElementById('overlay');
  const draw = document.getElementById('draw');
  const ctxO = overlay.getContext('2d');
  const ctxD = draw.getContext('2d', { alpha: true });
  const dot = document.getElementById('status-dot');
  const modeIndicator = document.getElementById('mode-indicator');
  const modeLabel = document.getElementById('mode-label');
  const toast = document.getElementById('toast');
  const clearBtn = document.getElementById('clear-btn');
  const strokeRange = document.getElementById('stroke');
  const strokeVal = document.getElementById('stroke-val');
  const showGuides = document.getElementById('guides');
  const palette = document.getElementById('palette');
  const eraserBtn = document.getElementById('eraser-btn');
  const savePhotoBtn = document.getElementById('save-photo-btn');
  const saveDrawingBtn = document.getElementById('save-drawing-btn');
  const saveCompositeBtn = document.getElementById('save-composite-btn');
  let strokeColor = '#e6e6e6'; // default (matches previous)
  let isErasing = false;

  // --- Position smoothing (EMA) ---
  let smoothPoint = null;           // filtered point (reduces jitter)
  const SMOOTHING = 0.22;           // 0..1 (lower = smoother, higher = snappier)

  // --- Pinch detection smoothing & debounce ---
  let distFilt = null;              // EMA for pinch distance
  const DIST_SMOOTH = 0.35;         // 0..1 (higher = snappier threshold distance)
  let pinchOnFrames = 0, pinchOffFrames = 0;
  const ON_FRAMES = 3, OFF_FRAMES = 3; // consecutive frames to toggle

  let pinchActive = false;
  let lastPoint = null; // {x,y}
  let guides = false;
  let lineWidth = +strokeRange.value;

  // Resize canvases to fill stage with devicePixelRatio for crisp lines
  const resize = () => {
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1)); // cap DPR for perf
    for (const c of [overlay, draw]) {
      const rect = c.parentElement.getBoundingClientRect();
      c.width  = Math.floor(rect.width * dpr);
      c.height = Math.floor(rect.height * dpr);
      c.style.width = rect.width + 'px';
      c.style.height = rect.height + 'px';
      const g = c.getContext('2d');
      g.setTransform(dpr, 0, 0, dpr, 0, 0);
    }
    // crisp stroke settings
    ctxD.lineCap = 'round';
    ctxD.lineJoin = 'round';
  };
  addEventListener('resize', resize, { passive:true });

  // --- Download helpers ---
  function tsName(){
    const d = new Date();
    const p = (n)=> String(n).padStart(2,'0');
    return `${d.getFullYear()}${p(d.getMonth()+1)}${p(d.getDate())}_${p(d.getHours())}${p(d.getMinutes())}${p(d.getSeconds())}`;
  }

  function downloadBlob(blob, filename){
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url; a.download = filename; document.body.appendChild(a); a.click();
    setTimeout(()=>{ URL.revokeObjectURL(url); a.remove(); }, 0);
  }

  function downloadCanvasPNG(canvas, filename){
    if (canvas.toBlob){
      canvas.toBlob((blob)=> downloadBlob(blob, filename), 'image/png');
    } else {
      const dataURL = canvas.toDataURL('image/png');
      const a = document.createElement('a');
      a.href = dataURL; a.download = filename; document.body.appendChild(a); a.click(); a.remove();
    }
  }

  function makeOffscreen(){
    const off = document.createElement('canvas');
    // Use the drawing canvas size (already DPR-adjusted in resize())
    off.width = draw.width; off.height = draw.height;
    // match CSS size for correct aspect
    off.style.width = draw.style.width; off.style.height = draw.style.height;
    const c = off.getContext('2d');
    // Apply same base transform as draw (set in resize)
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    c.setTransform(dpr, 0, 0, dpr, 0, 0);
    return { off, c };
  }

  function captureVideoFrameTo(ctx){
    // Mirror horizontally to match what the user sees (video is CSS-mirrored)
    const w = overlay.clientWidth; const h = overlay.clientHeight;
    ctx.save();
    ctx.translate(w, 0);
    ctx.scale(-1, 1);
    ctx.drawImage(video, 0, 0, w, h);
    ctx.restore();
  }

  // UI controls
  strokeRange.addEventListener('input', () => {
    lineWidth = +strokeRange.value;
    strokeVal.textContent = lineWidth;
  });
  showGuides.addEventListener('change', () => guides = showGuides.checked);
  clearBtn.addEventListener('click', () => {
    ctxD.clearRect(0,0,draw.width,draw.height);
    lastPoint = null;
    smoothPoint = null;
    ctxD.globalCompositeOperation = 'source-over';
  });

  // Save current camera photo
  if (savePhotoBtn){
    savePhotoBtn.addEventListener('click', () => {
      if (!video.videoWidth || !video.videoHeight){
        toast.textContent = 'Camera is not ready yet';
        toast.style.display = 'block'; setTimeout(()=> toast.style.display = 'none', 1800);
        return;
      }
      const { off, c } = makeOffscreen();
      captureVideoFrameTo(c);
      downloadCanvasPNG(off, `handdraw_photo_${tsName()}.png`);
    });
  }

  // Save only the drawing layer
  if (saveDrawingBtn){
    saveDrawingBtn.addEventListener('click', () => {
      downloadCanvasPNG(draw, `handdraw_drawing_${tsName()}.png`);
    });
  }

  // Save camera + drawing composited
  if (saveCompositeBtn){
    saveCompositeBtn.addEventListener('click', () => {
      if (!video.videoWidth || !video.videoHeight){
        toast.textContent = 'Camera is not ready yet';
        toast.style.display = 'block'; setTimeout(()=> toast.style.display = 'none', 1800);
        return;
      }
      const { off, c } = makeOffscreen();
      // 1) camera frame (mirrored)
      captureVideoFrameTo(c);
      // 2) drawing layer on top
      c.drawImage(draw, 0, 0, overlay.clientWidth, overlay.clientHeight);
      downloadCanvasPNG(off, `handdraw_all_${tsName()}.png`);
    });
  }

  // Color palette handler
  if (palette){
    palette.addEventListener('click', (e) => {
      const btn = e.target.closest('.swatch');
      if (!btn) return;
      const col = btn.getAttribute('data-color');
      if (!col) return;
      strokeColor = col;
      // visual selection
      palette.querySelectorAll('.swatch').forEach(s => s.classList.remove('selected'));
      btn.classList.add('selected');
    });
  }

  // Eraser toggle (uses destination-out compositing)
  if (eraserBtn){
    eraserBtn.addEventListener('click', () => {
      isErasing = !isErasing;
      eraserBtn.classList.toggle('active', isErasing);
    });
  }
  // Keyboard shortcuts: E = eraser, B = brush
  addEventListener('keydown', (e) => {
    if (e.target && (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA')) return;
    if (e.key === 'e' || e.key === 'E'){
      isErasing = !isErasing;
      if (eraserBtn) eraserBtn.classList.toggle('active', isErasing);
    } else if (e.key === 'b' || e.key === 'B'){
      isErasing = false;
      if (eraserBtn) eraserBtn.classList.remove('active');
    }
  });

  // Initialize MediaPipe Hands
  const hands = new Hands({
    locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
  });
  hands.setOptions({
    maxNumHands: 1,
    modelComplexity: 1,          // highest quality model
    minDetectionConfidence: 0.7, // stricter gate to reduce false hands
    minTrackingConfidence: 0.7   // steadier landmark tracking
  });

  hands.onResults(onResults);

  let camera;
  async function start(){
    resize();
    try{
      dot.classList.remove('on');
      // Camera from MediaPipe utils (handles mobile constraints nicely)
      camera = new Camera(video, {
        onFrame: async () => { await hands.send({ image: video }); },
        width: 1280,
        height: 720
      });
      await camera.start();
      dot.classList.add('on');
      hideToastSoon();
    }catch(err){
      console.error(err);
      toast.innerHTML = 'Camera access failed. Check permissions and reload.';
    }
  }

  function hideToastSoon(){
    setTimeout(()=> toast.style.display = 'none', 3200);
  }

  // Utility: normalized coords [0..1] -> canvas pixels
  function toCanvas(x, y){
    // video is mirrored via CSS; compensate by mirroring x
    const cx = overlay.clientWidth * (1 - x);
    const cy = overlay.clientHeight * y;
    return { x: cx, y: cy };
  }


  function onResults(results){
    const cw = overlay.clientWidth, ch = overlay.clientHeight;

    // Clear overlay (guides)
    ctxO.clearRect(0,0,cw,ch);

    if (!results.multiHandLandmarks || results.multiHandLandmarks.length === 0){
      setMode(false);
      lastPoint = null;
      ctxD.globalCompositeOperation = 'source-over';
      distFilt = null;
      pinchOnFrames = pinchOffFrames = 0;
      return;
    }

    const lm = results.multiHandLandmarks[0];

    // Thumb tip (4) & Index tip (8)
    const t = lm[4];
    const i = lm[8];

    // Euclidean distance in normalized space (index tip ↔ thumb tip)
    const dx = (t.x - i.x), dy = (t.y - i.y);
    let dist = Math.hypot(dx, dy);

    // Adaptive thresholds based on palm width (index MCP↔pinky MCP)
    const imcp = lm[5], pmcp = lm[17];
    const palmWidth = Math.hypot(imcp.x - pmcp.x, imcp.y - pmcp.y);

    // Depth gate: ensure fingertips are near same z-plane to reduce false pinches
    const zClose = Math.abs((t.z || 0) - (i.z || 0)) < 0.08;

    // Smooth the pinch distance
    if (distFilt == null) distFilt = dist;
    else distFilt += (dist - distFilt) * DIST_SMOOTH;

    // Dynamic hysteresis (scaled by hand size), with sane lower bounds
    const onThresh  = Math.max(0.015, palmWidth * 0.32);
    const offThresh = Math.max(0.020, palmWidth * 0.42);

    // Debounced state machine
    if (zClose && distFilt < onThresh) {
      pinchOnFrames++; pinchOffFrames = 0;
      if (!pinchActive && pinchOnFrames >= ON_FRAMES) pinchActive = true;
    } else if (distFilt > offThresh || !zClose) {
      pinchOffFrames++; pinchOnFrames = 0;
      if (pinchActive && pinchOffFrames >= OFF_FRAMES) pinchActive = false;
    } else {
      // in the hysteresis band: do not accumulate either counter
      pinchOnFrames = 0; pinchOffFrames = 0;
    }
    setMode(pinchActive);

    // Midpoint of pinch (in normalized space)
    const mid = { x: (t.x + i.x) * 0.5, y: (t.y + i.y) * 0.5 };
    const p = toCanvas(mid.x, mid.y);

    // Exponential moving average to reduce jitter
    if (!smoothPoint) {
      smoothPoint = { x: p.x, y: p.y };
    } else {
      smoothPoint.x += (p.x - smoothPoint.x) * SMOOTHING;
      smoothPoint.y += (p.y - smoothPoint.y) * SMOOTHING;
    }
    const pf = smoothPoint;

    // Draw persistent line when pinched (using filtered point)
    if (pinchActive){
      const cur = pf;
      if (!lastPoint) lastPoint = cur;
      const dxp = cur.x - lastPoint.x, dyp = cur.y - lastPoint.y;
      const distPix = Math.hypot(dxp, dyp);
      const steps = Math.max(1, Math.min(8, Math.floor(distPix / 3)));
      ctxD.globalAlpha = 0.95;
      ctxD.globalCompositeOperation = isErasing ? 'destination-out' : 'source-over';
      ctxD.strokeStyle = strokeColor;
      ctxD.lineWidth = lineWidth;
      ctxD.beginPath();
      ctxD.moveTo(lastPoint.x, lastPoint.y);
      for (let s=1; s<=steps; s++){
        const xx = lastPoint.x + dxp * (s/steps);
        const yy = lastPoint.y + dyp * (s/steps);
        ctxD.lineTo(xx, yy);
      }
      ctxD.stroke();
      ctxD.globalAlpha = 1;
      lastPoint = cur;
    } else {
      lastPoint = null;
      smoothPoint = null;
      distFilt = null;
      ctxD.globalCompositeOperation = 'source-over';
    }

    // Optional guides
    if (guides){
      // fingertips & pinch line
      const tt = toCanvas(t.x, t.y);
      const ii = toCanvas(i.x, i.y);
      ctxO.globalAlpha = 0.9;
      ctxO.strokeStyle = 'rgba(156,197,255,.5)';
      ctxO.lineWidth = 2;
      ctxO.beginPath(); ctxO.moveTo(tt.x, tt.y); ctxO.lineTo(ii.x, ii.y); ctxO.stroke();
      ctxO.fillStyle = 'rgba(156,197,255,.9)';
      ctxO.beginPath(); ctxO.arc(tt.x, tt.y, 5, 0, Math.PI*2); ctxO.fill();
      ctxO.beginPath(); ctxO.arc(ii.x, ii.y, 5, 0, Math.PI*2); ctxO.fill();

      // pinch dot (use filtered point for steadier indicator)
      const pd = pinchActive ? pf : p;
      ctxO.fillStyle = pinchActive ? 'rgba(48,209,88,.95)' : 'rgba(200,200,200,.7)';
      ctxO.beginPath(); ctxO.arc(pd.x, pd.y, 6, 0, Math.PI*2); ctxO.fill();
      ctxO.globalAlpha = 1;
    }
  }

  function setMode(active){
    if (active){
      modeLabel.textContent = isErasing ? 'Erasing' : 'Drawing';
      modeIndicator.style.borderColor = isErasing ? 'rgba(255,149,0,.35)' : 'rgba(48,209,88,.35)';
      modeIndicator.style.boxShadow = 'inset 0 0 0 1px ' + (isErasing ? 'rgba(255,149,0,.15)' : 'rgba(48,209,88,.15)');
    } else {
      modeLabel.textContent = 'Idle';
      modeIndicator.style.borderColor = '';
      modeIndicator.style.boxShadow = '';
    }
  }

  // Kick off
  start();
})();
</script>
</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ChaosNet — Settings</title>
  <link rel="icon" type="image/png" href="img/ChaosNetLogo.png" />
  <link rel="shortcut icon" href="img/ChaosNetLogo.png" type="image/png" />
    <!-- iOS home screen icon + web app meta -->
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
  <link rel="apple-touch-icon" href="/img/ChaosNetLogo.png">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-title" content="ChaosNet">
  <link rel="stylesheet" href="css/chatStyle.css" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <style>
    :root { --bg:#1e1e1e; --card:#2a2a2a; --accent:#ff8c00; --text:#fff; --muted:#bdbdbd; --stroke:#444; }
    *{ box-sizing:border-box; }
    html,body{ height:100%; }
    body{ margin:0; font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,"Helvetica Neue",Arial; background:var(--bg); color:var(--text); }

    /* Top bar */
    .topbar{ display:flex; align-items:center; justify-content:space-between; padding:12px 16px; background:#1e1e1e; border-bottom:1px solid var(--stroke); }
    .topbar h2{ margin:0; font-size:18px; color:var(--accent); }
    .back-btn{ background:var(--accent); border:none; padding:8px 12px; border-radius:10px; cursor:pointer; display:flex; align-items:center; gap:8px; }
    .back-btn img{ height:22px; display:block; }

    /* Layout */
    .wrap{ max-width:980px; margin:0 auto; padding:16px; display:grid; grid-template-columns: 320px 1fr; gap:24px; }
    @media (max-width: 820px){ .wrap{ grid-template-columns: 1fr; } }

    /* Left: avatar */
    .avatar-card{ background:var(--card); border:1px solid var(--stroke); border-radius:16px; padding:24px; position:relative; }
    .avatar-box{
      width:100%;
      aspect-ratio: 1 / 1;
      display:flex; align-items:center; justify-content:center;
      position: relative;
    }
    .avatar-bg{
      position:absolute; width:200px; height:200px; border-radius:50%;
      background:var(--bg); /* цвет нижнего слоя */
      top:50%; left:50%; transform:translate(-50%, -50%);
      z-index: 0;
    }
    .avatar-box img { cursor: pointer; }
    .avatar-pick{ display:inline-block; position:relative; z-index:1; cursor:pointer; border-radius:50%; }
    .avatar-pick img{ pointer-events:none; }
    .avatar-del{
        position:absolute; right:12px; bottom:12px;
    }

    /* Right side: form */
    .card{ background:var(--card); border:1px solid var(--stroke); border-radius:16px; padding:24px; }
    .card h3{ margin:0 0 16px; color:#ff8c00; font-size:18px; }

    .form{ display:flex; flex-direction:column; gap:14px; }
    .row{ display:flex; flex-direction:column; gap:6px; }
    label{ font-size:13px; color:#ff8c00; }
    input[type="text"], input[type="password"]{
      background:#1e1e1e; color:var(--text); border:1px solid var(--stroke); border-radius:12px; padding:12px 14px; font-size:15px;
      outline:none; transition:border .15s ease; width:100%;
    }
    input::placeholder{ color:#ff8c00; opacity:.9; }
    input:focus{ border-color:#666; }

    .password-row { position: relative; }
    .password-row .pwd-toggle {
      position: absolute; right: 12px;
      background: transparent; border: none; padding: 0; cursor: pointer;
      line-height: 0;
      display: flex; align-items: flex-end; justify-content: center;
      height: 100%;
      padding-bottom: 11px; /* тонкая подстройка по вертикали */
    }
    .password-row .pwd-toggle img { display: block; width: 20px; height: 20px; }
    .password-row .pwd-edit {
      position: absolute; right: 44px;
      background: transparent; border: none; padding: 0; cursor: pointer;
      line-height: 0;
      display: flex; align-items: flex-end; justify-content: center;
      height: 100%;
      padding-bottom: 13px; /* на 2px выше глаза */
    }
    .password-row .pwd-edit img { display: block; width: 20px; height: 20px; }
    /* Nick edit button (same positioning as password) */
    .nick-row { position: relative; }
    .nick-row .nick-edit {
      position: absolute; right: 12px;
      background: transparent; border: none; padding: 0; cursor: pointer;
      line-height: 0;
      display: flex; align-items: flex-end; justify-content: center;
      height: 100%;
      padding-bottom: 13px; /* aligns with baseline similar to .pwd-edit */
    }
    .nick-row .nick-edit img { display: block; width: 20px; height: 20px; }

    .buttons{ display:flex; gap:10px; flex-wrap:wrap; margin-top:8px; }
    .btn{ background:var(--accent); color:#fff; border:none; padding:10px 14px; border-radius:12px; font-size:15px; cursor:pointer; }
    .btn.secondary{ background:#3a3a3a; }
    .file-hidden{ position: fixed; left: -9999px; top: -9999px; width: 1px; height: 1px; opacity: 0; }
    #deleteAcc { margin-left: auto; }

    .note{ margin-top:8px; font-size:12px; color:var(--muted); }
    .status{ margin-top:10px; font-size:14px; }
    .ok{ color:#78d18b; }
    .err{ color:#ff6b6b; }

    /* Avatar cropper modal */
    .crop-modal{ position:fixed; inset:0; background:rgba(0,0,0,.6); display:none; align-items:center; justify-content:center; z-index:9999; }
    .crop-modal.show{ display:flex; }
    .crop-dialog{ background:#2a2a2a; border:1px solid var(--stroke); border-radius:16px; padding:16px; width:min(92vw, 520px); }
    .crop-title{ color:#ff8c00; margin:0 0 10px; font-size:16px; }
    .crop-stage{ position:relative; width:100%; aspect-ratio:1/1; background:#1e1e1e; border-radius:12px; overflow:hidden; }
    #cropCanvas{ width:100%; height:100%; display:block; }
    /* circular mask overlay */
    .crop-mask{ pointer-events:none; position:absolute; inset:0; background:radial-gradient(circle at 50% 50%, transparent 36%, rgba(0,0,0,.55) 37%); }
    .crop-controls{ display:flex; align-items:center; gap:12px; margin-top:12px; flex-wrap:wrap; }
    .crop-controls .range{ flex:1; }
    .crop-btn{ background:#3a3a3a; color:#fff; border:none; border-radius:10px; padding:8px 12px; cursor:pointer; }
    .crop-btn.primary{ background:#ff8c00; color:#000; }
  </style>
</head>
<body>
  <div class="topbar">
    <h2>Account Settings</h2>
    <a href="select.html" style="text-decoration:none;">
      <button class="back-btn" title="Back">
        <img src="img/leave.png" alt="Back" />
      </button>
    </a>
  </div>

  <main class="wrap">
    <!-- Left side: avatar -->
    <section class="avatar-card">
      <div class="avatar-box">
        <div class="avatar-bg"></div>
        <label for="avatarInput" class="avatar-pick">
          <img src="img/user.png" alt="Avatar" style="width:220px;height:220px;border-radius:50%;object-fit:cover;display:block;" />
        </label>
        <input type="file" id="avatarInput" accept="image/png,image/jpeg,image/webp" class="file-hidden" />
      </div>
      <div id="userNameDisplay" style="color:#ff8c00; text-align:center; margin-top:12px; font-weight:500;"></div>
      <div id="adminStatusDisplay" style="color:#ff8c00; text-align:center; font-size:14px;"></div>
      <button type="button" id="deleteAvatar" class="btn secondary avatar-del" style="color:#ff8c00;" title="Remove avatar" aria-label="Remove avatar">Delete avatar</button>
    </section>

    <!-- Right side: account form -->
    <section class="card">
      <h3>Profiles</h3>
      <form id="settings-form" class="form" autocomplete="off">
        <div class="row nick-row">
          <button type="button" class="nick-edit" id="editNick" aria-label="Edit nick" title="Edit nick">
            <img src="img/edit.png" alt="Edit nick" />
          </button>
          <label for="nick">Nick</label>
          <input id="nick" type="text" placeholder="Your nickname" readonly aria-readonly="true" />
        </div>
        <div class="row">
          <label for="userid">ID</label>
          <input id="userid" type="text" placeholder="Unique ID" readonly aria-readonly="true" />
        </div>
        <div class="row password-row">
          <button type="button" class="pwd-edit" id="editPwd" aria-label="Edit password" title="Edit password">
            <img src="img/edit.png" alt="Edit" />
          </button>
          <button type="button" class="pwd-toggle" id="togglePwd" aria-label="Toggle password visibility" title="Show/Hide password">
            <img id="togglePwdIcon" src="img/view.png" alt="Toggle" />
          </button>
          <label for="password">Password</label>
          <input id="password" type="password" placeholder="••••••••" style="padding:12px 74px 12px 14px;" readonly aria-readonly="true" />
        </div>

        <div class="buttons">
          <button type="button" class="btn" id="saveLocal" style="color:#000000;">Save</button>
          <button type="button" class="btn secondary" id="logoutBtn" style="color:#ff8c00;">Log out</button>
          <button type="button" class="btn secondary" id="deleteAcc" style="color:#ff8c00;">Delete Account</button>
        </div>
        <div id="status" class="status"></div>
      </form>
    </section>
  </main>

  <script>
    const el = (id)=>document.getElementById(id);
    const statusEl = el('status');
    let _avatarSelectedFile = null; // holds file chosen for upload until Save

    // Init: do NOT prefill from localStorage; only use userID to fetch real data from server.
    (function init(){
      try{
        el('nick').value = '';
        el('userid').value = '';
        el('password').value = '';

        const uid = localStorage.getItem('userid') || localStorage.getItem('userID');
        if (uid) {
          fetch('/get-user', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ id: uid })
          })
          .then(r => r.ok ? r.json() : Promise.reject(r))
          .then(user => {
            if (user.nick) {
              el('nick').value = user.nick;
              const userNameDisplay = document.getElementById('userNameDisplay');
              if (userNameDisplay) userNameDisplay.textContent = user.nick;
            }
            if (user.id) el('userid').value = user.id;
            if (typeof user.password === 'string') el('password').value = user.password;

            const avatarLink = user.avatar || user.avatar_url;
            if (avatarLink) {
              const avatarImg = document.querySelector('.avatar-box img');
              if (avatarImg) {
                const bust = avatarLink + (avatarLink.includes('?') ? '&' : '?') + 'v=' + Date.now();
                avatarImg.src = bust; // cache-busting
              }
            }
            if (typeof user.AdminStatus === 'boolean') {
              const adminStatusDisplay = document.getElementById('adminStatusDisplay');
              if (adminStatusDisplay) adminStatusDisplay.textContent = user.AdminStatus ? 'Admin' : '';
            }
          })
          .catch(err => { try { console.debug('get-user failed', err); } catch(_){} });
        }
      } catch(e) {}
    })();

    // Avatar picker + cropper (run after DOM ready)
    document.addEventListener('DOMContentLoaded', () => {
      const avatarImg = document.querySelector('.avatar-box img');
      const avatarInput = document.getElementById('avatarInput');
      const cropModal = document.getElementById('cropModal');
      const cropCanvas = document.getElementById('cropCanvas');
      const zoomRange = document.getElementById('zoomRange');
      const zoomInBtn = document.getElementById('zoomIn');
      const zoomOutBtn = document.getElementById('zoomOut');
      const cropCancel = document.getElementById('cropCancel');
      const cropApply = document.getElementById('cropApply');
      const cropStage = document.querySelector('#cropModal .crop-stage');
      const cropMask  = document.querySelector('#cropModal .crop-mask');

      let maskDiameter = 0;

      if (!avatarImg || !avatarInput || !cropModal || !cropCanvas || !zoomRange || !zoomInBtn || !zoomOutBtn || !cropCancel || !cropApply || !cropStage || !cropMask) {
        console.warn('Cropper elements missing');
        return;
      }

      function updateMaskDiameter(){
        if (!cropStage || !cropMask) return;
        const avatarEl = document.querySelector('.avatar-box img');
        const targetDiameter = avatarEl ? avatarEl.clientWidth : 220;
        const stageRect = cropStage.getBoundingClientRect();
        const diameter = Math.min(targetDiameter, stageRect.width, stageRect.height);
        maskDiameter = diameter;
        const r = Math.floor(diameter / 2);
        cropMask.style.background = `radial-gradient(circle ${r}px at 50% 50%, transparent ${r - 0.5}px, rgba(0,0,0,.55) ${r}px)`;
      }
      window.addEventListener('resize', () => {
        if (cropModal && cropModal.classList.contains('show')) updateMaskDiameter();
      });

      let ctx, img, scale=1, minScale=1, maxScale=4, tx=0, ty=0;
      let dragging=false, lastX=0, lastY=0;
      let touchMode=false, lastDist=0;

      function openCropper(dataUrl){
        const size = Math.min(window.innerWidth*0.9, 480);
        cropCanvas.width = size; cropCanvas.height = size;
        ctx = cropCanvas.getContext('2d');

        img = new Image();
        img.onload = () => {
          const sx = size / img.width;
          const sy = size / img.height;
          minScale = Math.max(sx, sy);
          scale = Math.max(minScale, 1);
          maxScale = Math.max(4, minScale*4);
          tx = size/2; ty = size/2;
          zoomRange.min = Math.max(0.2, minScale * 0.25).toFixed(2);
          zoomRange.max = maxScale.toFixed(2);
          zoomRange.value = scale.toFixed(2);
          render();
          cropModal.classList.add('show');
          cropModal.setAttribute('aria-hidden','false');
          Promise.resolve().then(updateMaskDiameter);
        };
        img.src = dataUrl;
      }

      function render(){
        const w = cropCanvas.width, h = cropCanvas.height;
        ctx.clearRect(0,0,w,h);
        ctx.fillStyle = '#1e1e1e';
        ctx.fillRect(0,0,w,h);
        ctx.save();
        ctx.translate(tx,ty);
        ctx.scale(scale, scale);
        ctx.drawImage(img, -img.width/2, -img.height/2);
        ctx.restore();
      }

      function setScale(s, cx, cy){
        const prev = scale;
        scale = Math.min(Math.max(s, parseFloat(zoomRange.min)), parseFloat(zoomRange.max));
        const k = scale/prev;
        tx = cx - (cx - tx) * k;
        ty = cy - (cy - ty) * k;
        zoomRange.value = scale.toFixed(2);
        render();
      }

      cropCanvas.addEventListener('mousedown', e=>{
        dragging = true; lastX = e.offsetX; lastY = e.offsetY;
      });
      window.addEventListener('mouseup', ()=> dragging=false);
      cropCanvas.addEventListener('mousemove', e=>{
        if(!dragging) return;
        const dx = e.offsetX - lastX; const dy = e.offsetY - lastY;
        lastX = e.offsetX; lastY = e.offsetY;
        tx += dx; ty += dy; render();
      });
      cropCanvas.addEventListener('wheel', e=>{
        e.preventDefault();
        const rect = cropCanvas.getBoundingClientRect();
        const cx = e.clientX - rect.left; const cy = e.clientY - rect.top;
        const delta = e.deltaY < 0 ? 1.08 : 0.92;
        setScale(scale * delta, cx, cy);
      }, { passive:false });

      cropCanvas.addEventListener('touchstart', e=>{
        if (e.touches.length === 1){
          touchMode = true; dragging = true;
          const t = e.touches[0];
          const rect = cropCanvas.getBoundingClientRect();
          lastX = t.clientX - rect.left; lastY = t.clientY - rect.top;
        } else if (e.touches.length === 2){
          touchMode = true; dragging = false;
          lastDist = Math.hypot(
            e.touches[0].clientX - e.touches[1].clientX,
            e.touches[0].clientY - e.touches[1].clientY
          );
        }
      }, { passive:true });
      cropCanvas.addEventListener('touchmove', e=>{
        if (!touchMode) return;
        const rect = cropCanvas.getBoundingClientRect();
        if (e.touches.length === 1 && dragging){
          const t = e.touches[0];
          const x = t.clientX - rect.left; const y = t.clientY - rect.top;
          const dx = x - lastX; const dy = y - lastY;
          lastX = x; lastY = y; tx += dx; ty += dy; render();
        } else if (e.touches.length === 2){
          const d = Math.hypot(
            e.touches[0].clientX - e.touches[1].clientX,
            e.touches[0].clientY - e.touches[1].clientY
          );
          const cx = (e.touches[0].clientX + e.touches[1].clientX)/2 - rect.left;
          const cy = (e.touches[0].clientY + e.touches[1].clientY)/2 - rect.top;
          const factor = d / (lastDist || d);
          lastDist = d;
          setScale(scale * factor, cx, cy);
        }
      }, { passive:false });
      cropCanvas.addEventListener('touchend', ()=>{ dragging=false; touchMode=false; lastDist=0; }, { passive:true });

      zoomRange.addEventListener('input', ()=> setScale(parseFloat(zoomRange.value), cropCanvas.width/2, cropCanvas.height/2));
      zoomInBtn.addEventListener('click', ()=> setScale(scale*1.12, cropCanvas.width/2, cropCanvas.height/2));
      zoomOutBtn.addEventListener('click', ()=> setScale(scale/1.12, cropCanvas.width/2, cropCanvas.height/2));

      cropCancel.addEventListener('click', ()=>{ cropModal.classList.remove('show'); cropModal.setAttribute('aria-hidden','true'); avatarInput.value=''; });

      cropApply.addEventListener('click', ()=>{
        const outSize = 512;
        const off = document.createElement('canvas');
        off.width = outSize; off.height = outSize;
        const octx = off.getContext('2d');

        const D = maskDiameter && maskDiameter > 0 ? maskDiameter : cropCanvas.width;
        const k = outSize / D;
        const size = cropCanvas.width;

        octx.fillStyle = '#1e1e1e';
        octx.fillRect(0,0,outSize,outSize);
        octx.save();
        octx.translate(
          (outSize/2) + (tx - size/2) * k,
          (outSize/2) + (ty - size/2) * k
        );
        octx.scale(scale * k, scale * k);
        octx.drawImage(img, -img.width/2, -img.height/2);
        octx.restore();

        off.toBlob(async (blob)=>{
          if (!blob) return;
          const file = new File([blob], 'avatar.jpg', { type: 'image/jpeg' });
          _avatarSelectedFile = file;
          const reader = new FileReader();
          reader.onload = ()=>{ avatarImg.src = reader.result; };
          reader.readAsDataURL(file);
          cropModal.classList.remove('show');
          cropModal.setAttribute('aria-hidden','true');
        }, 'image/jpeg', 0.92);
      });

      // label triggers native picker; we only listen to change
      avatarInput.addEventListener('change', () => {
        const f = avatarInput.files && avatarInput.files[0];
        _avatarSelectedFile = null;
        if (f) {
          const reader = new FileReader();
          reader.onload = () => openCropper(reader.result);
          reader.readAsDataURL(f);
        }
      });
    });

    // Name label (no localStorage reads)
    try {
      const userNameDisplay = el('userNameDisplay');
      const nickInput = el('nick');
      userNameDisplay.textContent = nickInput.value || '';
      nickInput.addEventListener('input', () => {
        userNameDisplay.textContent = nickInput.value;
      });
    } catch(e){}

    function setStatus(text, ok){
      statusEl.textContent = text || '';
      statusEl.className = 'status ' + (ok ? 'ok' : 'err');
    }

    // Delete account
    el('deleteAcc').addEventListener('click', async ()=>{
      const id = el('userid').value.trim();
      const password = el('password').value;
      if (!id) return setStatus('Missing user ID.', false);
      const agree = confirm('Delete account permanently? This action cannot be undone.');
      if (!agree) return;
      try {
        const res = await fetch('/delete-user', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ id, password })
        });
        if (!res.ok) {
          const tx = await res.text().catch(()=> 'Server error');
          return setStatus('Failed to delete account: ' + tx, false);
        }
        setStatus('Account deleted.', true);
        try {
          localStorage.removeItem('username');
          localStorage.removeItem('userid');
          localStorage.removeItem('userID');
          localStorage.removeItem('password');
          localStorage.removeItem('Subscription');
          localStorage.removeItem('isAdmin');
          localStorage.removeItem('rooms');
        } catch(_) {}
        window.location.assign('login.html');
      } catch (e) {
        setStatus('Network error while deleting account.', false);
      }
    });

    // Save → update nick/password then (if selected) upload avatar
    el('saveLocal').addEventListener('click', async ()=>{
      const nick = el('nick').value.trim();
      const id = el('userid').value.trim();
      const password = el('password').value;
      if(!id){ return setStatus('Missing user ID.', false); }
      if(!nick){ return setStatus('Nick is required.', false); }

      const btn = document.getElementById('saveLocal');
      btn.disabled = true;

      try {
        const res = await fetch('/update-user', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ id, password, nick })
        });

        if (!res.ok) {
          const tx = await res.text().catch(()=> 'Server error');
          setStatus('Failed to save: ' + tx, false);
          return;
        }

        // server returns the updated user row
        const updated = await res.json().catch(()=> null);
        setStatus('Saved.', true);

        // If server echoed new nick, update UI + localStorage
        if (updated && updated.nick) {
          try { localStorage.setItem('username', updated.nick); } catch(_) {}
          const userNameDisplay = document.getElementById('userNameDisplay');
          if (userNameDisplay) userNameDisplay.textContent = updated.nick;
          const nickInput = el('nick');
          if (nickInput) {
            nickInput.value = updated.nick;
            nickInput.readOnly = true;
            nickInput.setAttribute('aria-readonly','true');
          }
        }

        // Avatar upload (optional)
        if (_avatarSelectedFile) {
          try {
            const limit = 7*1024*1024; // fixed limit; no localStorage involved
            if (_avatarSelectedFile.size > limit) {
              setStatus('Avatar is too large (max 7MB)', false);
            } else if (!/^image\/(png|jpeg|webp)$/.test(_avatarSelectedFile.type)) {
              setStatus('Only PNG/JPEG/WebP are allowed', false);
            } else {
              const fd = new FormData();
              fd.append('avatar', _avatarSelectedFile);
              fd.append('id', id);
              const up = await fetch('/avatar/upload', { method:'POST', body: fd });
              if (up.ok) {
                const upd2 = await up.json();
                const newLink = upd2.avatar || upd2.avatar_url;
                if (newLink) {
                  const avatarImg = document.querySelector('.avatar-box img');
                  if (avatarImg) {
                    const bustNew = newLink + (newLink.includes('?') ? '&' : '?') + 'v=' + Date.now();
                    avatarImg.src = bustNew; // cache-busting
                  }
                  setStatus('Avatar saved.', true);
                  _avatarSelectedFile = null;
                }
              } else {
                const tx = await up.text().catch(()=> 'Server error');
                setStatus('Failed to save avatar: ' + tx, false);
              }
            }
          } catch(e) {
            setStatus('Network error while saving avatar.', false);
          }
        }
      } catch (e) {
        setStatus('Network error while saving.', false);
      } finally {
        btn.disabled = false;
      }
    });

    // Logout
    el('logoutBtn').addEventListener('click', ()=>{
      try{
        localStorage.removeItem('username');
        localStorage.removeItem('userid');
        localStorage.removeItem('userID');
        localStorage.removeItem('password');
        localStorage.removeItem('Subscription');
        localStorage.removeItem('isAdmin');
        localStorage.removeItem('rooms');
      }catch(e){}
      window.location.assign('login.html');
    });

    // Delete avatar (set to null on server)
    try {
      const delBtn = document.getElementById('deleteAvatar');
      if (delBtn) {
        delBtn.addEventListener('click', async ()=>{
          const id = el('userid').value.trim();
          if (!id) { setStatus('Missing user ID.', false); return; }
          delBtn.disabled = true;
          try {
            const r = await fetch('/avatar/remove', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ id })
            });
            if (!r.ok) {
              const tx = await r.text().catch(()=> 'Server error');
              setStatus('Failed to remove avatar: ' + tx, false);
            } else {
              // Reset UI to default avatar
              const avatarImg = document.querySelector('.avatar-box img');
              if (avatarImg) avatarImg.src = 'img/user.png';
              _avatarSelectedFile = null;
              setStatus('Avatar removed.', true);
            }
          } catch (e) {
            setStatus('Network error while removing avatar.', false);
          } finally {
            delBtn.disabled = false;
          }
        });
      }
    } catch(e){}

    // Edit nick toggle (enable/disable readonly)
    try {
      const nickInputEditable = el('nick');
      const editNickBtn = document.getElementById('editNick');
      let nickEditable = false;
      if (editNickBtn && nickInputEditable) {
        editNickBtn.addEventListener('click', () => {
          nickEditable = !nickEditable;
          nickInputEditable.readOnly = !nickEditable;
          nickInputEditable.setAttribute('aria-readonly', String(!nickEditable));
          if (nickEditable) {
            nickInputEditable.focus();
            // place caret at end
            const v = nickInputEditable.value; nickInputEditable.value = ''; nickInputEditable.value = v;
          }
        });
      }
    } catch(e){}

    // Edit password toggle (enable/disable readonly)
    try {
      const pwdInput = el('password');
      const editBtn = document.getElementById('editPwd');
      let editable = false;
      editBtn.addEventListener('click', () => {
        editable = !editable;
        pwdInput.readOnly = !editable;
        pwdInput.setAttribute('aria-readonly', String(!editable));
      });
    } catch(e){}

    // Show/Hide password
    try {
      const pwdInput2 = el('password');
      const toggleBtn = document.getElementById('togglePwd');
      const toggleIcon = document.getElementById('togglePwdIcon');
      if (pwdInput2 && toggleBtn && toggleIcon) {
        toggleBtn.addEventListener('click', () => {
          const nowHidden = pwdInput2.type === 'password';
          pwdInput2.type = nowHidden ? 'text' : 'password';
          toggleIcon.src = nowHidden ? 'img/hide.png' : 'img/view.png';
        });
      }
    } catch(e){}
  </script>

  <!-- Avatar Cropper Modal -->
  <div id="cropModal" class="crop-modal" aria-hidden="true">
    <div class="crop-dialog" role="dialog" aria-modal="true" aria-labelledby="cropTitle">
      <h3 id="cropTitle" class="crop-title">Adjust avatar</h3>
      <div class="crop-stage">
        <canvas id="cropCanvas"></canvas>
        <div class="crop-mask"></div>
      </div>
      <div class="crop-controls">
        <button type="button" class="crop-btn" id="zoomOut">−</button>
        <input type="range" min="0.2" max="4" step="0.01" value="1" id="zoomRange" class="range" />
        <button type="button" class="crop-btn" id="zoomIn">+</button>
        <div style="flex:1"></div>
        <button type="button" class="crop-btn" id="cropCancel">Cancel</button>
        <button type="button" class="crop-btn primary" id="cropApply">Use this</button>
      </div>
    </div>
  </div>
</body>
</html>